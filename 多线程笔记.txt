1： 一边听歌, 一遍写文章的;


app: music / doc

   编辑一个文字的时候，是否等待用户的输入;
   1秒写一个文字, 花CPU 0.001s;
   解码 1秒的音频数据，丢给声卡播放, 0.001s; 0.999 编辑一个文字了; 0.998, 休眠, 调度给其它应用;
   1秒 0.9秒， 送1秒的数据给声卡，就可以了; 0.01 --> 声卡 1秒 ,
   切换调度;
   App Sleep(); CPU --> 给其他的使用; 
   


线程 --> OS 调度的最小单位;  Operate System  操作系统; --> OS;


// 线程，是让CPU，可以独立调度的最小的单位;
  APP --》 进程 --> 第一个线程; // 核心1
                --> 第二个线程; // 核心2
                --> 第三个线程; // 核心3 发挥CPU的多核优势;
   

   线程与线程之间 ，公用  代码段: 函数指令， 线程A，可以执行，线程B也可以执行;  同一个函数，可以再线程A 调用，也可以再线程B调用；
                         堆:(复杂对象分配的地方), 线程A ，访问对象M， 线程B也可以访问这个对象M； 同一个new 对象，可以再线程A使用，可以再线程B 使用;
                         不公用栈： 每个线程的函数调用的，参数/局部变量，是不同的; 参数，栈不一样;

                        struct XXXX ; 栈，不一样的;


  两个线程来访问同一个资源，是不是就由冲突;
   线程 先尝试 去 lock, unlock  
                       
   线程再来请求这个lock 挂起，等待 --> lock

   lock  unlock 之前，我们是线程安全的，有并且只有一个线程能访问;

   访问资源，没有冲突，就不要加锁; 


死锁
   L1, L2 AB
   A L1L2
   B L2L1




 